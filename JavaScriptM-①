Ajax优点：
<1>无刷新更新数据：在不刷新整个页面的情况下，与服务器通信维护数据。
<2>异步与服务器进行通信。
<3>前端和后端负载均衡：ajax可以把服务器负责的工作装换到客服端，利用客服端闲置的能力来处理，减少带宽和服务器的负担。
<4>基于标准被广泛支持。
<5>页面与应用分离：数据与呈现分离，有利于分工合作，提高工作效率。
Ajax缺点：
<1>ajax破坏了Back和History功能，即对浏览器的机制的破坏。
<2>安全存在问题。
<3>对搜索引擎的支持比较差：如果使用不当，会增大网络流量，降低系统性能。
<4>不能很好的支持移动设备。

http状态码
200	请求已成功，请求所希望的响应头或数据体将随此响应返回。
201	请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。
202	服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便 的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接 直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测 的指针，以便用户能够估计操作是否已经完成。
203	服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版 本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。
204	服务器成功处理了请求，但没有返回任何内容。
205	服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。
300	被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定 向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。
301	请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。
302	请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。
303	当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。
304	 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。但是请求了服务器。。
400	1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。
401	当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么 浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。
402	该状态码是为了将来可能的需求而预留的。
403	服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得 任何信息。
404	请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使 用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示 到底为何请求被拒绝或者没有其他适合的响应可用的情况下。
405	请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。
406	请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。
407	　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。
408	请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
409	由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新 提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时， 响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。
410	被请求的资源在服务器上已经不再可用，而且没有任何已知的
500	服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
503	由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可 以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。

同源策略？
同源策略是一种约定，他是浏览器最核心安全功能，如果缺少了同源策略，浏览器的正常工作可能要受影响。
同源策略又叫安全策略，脚本不能读取从不同的服务器载入的文档内容，除非这个文档就是包含改脚本的文档，
类似的一个脚本不能在来自不同的服务器注册事件。


js跨域问题？
什么是js跨域：js跨域是值在不同的域之间进行数据传输或者通信。只要是端口，域名，协议不一样就是不同的域。
简单点理解就是javaScript同源策略的限制。（端口和协议不同只能通过后端来处理）

怎么实现跨域？
在介绍解决方案之前想介绍一下跨域资源共享（cors），定义了在跨域资源访问的时候，浏览器和服务器应该怎么样沟通，
基本思路是使用自定义的http头部让浏览器和服务器进行通信，从而决定请求或者响应是不是成功。

跨域的解决方法？
（1）jsonp（json with padding）是资料格式json的一种使用格式。jsonp也叫填充式json是json的一种新的用法，只不过是被包含在函数中的。
  JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。
  js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
  所以jsonp是需要服务器端的页面进行相应的配合的。
  JSONP的优缺点
JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，
              不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。
JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间
              如何进行JavaScript调用的问题。
CORS与JSONP相比，无疑更为先进、方便和可靠。
    1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。
    2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。
    3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。
    
    
（2）通过document.domain来实现跨域
浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 
它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。
有一点需要说明，不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但蛋疼的是你却不能使用获取到的window对象的属性
和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获
取到一个几乎无用的window对象，这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 
http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，
我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 
可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，
也不可以设成baidu.com,因为主域已经不相同了。
优点：简单易使用，主流的浏览器都是支持的。
缺点：如果修改document.domain,则在某些机器上的IE678获取location.href有权限问题。
      如果修改了documenbt.domain,那么包含它的iframe也要修改，不然不能进行交互，并且影响其他的功能。
      如果修改了doucument.domain，导致IE6无法向一个iframe提交表单。
（3）window.name来实现跨域。
  window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，
  每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
  即是在不同的域中，window.name也是可以实现的。
  优点：操作简单，没有太大的问题，比较完美。
  缺点：暂无
（4）使用HTML5中新引进的window.postMessage方法来跨域传送数据。
window.postMessage(message,targetOrigin)  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；
第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。
需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。
上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。
在讨论第二种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。



随机产生 100 个从 0 ~ 1000 之间不重复的整数？
 var arr = [];
        for ( var i=0; i<100; i++ ){
                arr.push( Math.round( Math.random()*1000 ) );   //获取100个随机数
        }
        gm_removeDup(arr)   //去除重复
        for ( var i=arr.length; i<100; i++ ) {
                arr.push( Math.round( Math.random()*1000 ) );          
                arr.sort(gm_compare)  //排序
        }
function gm_removeDup(obj) {
        for ( var i=0; i<obj.length; i++) {
                for ( var j=i+1; j<obj.length; j++ ) {
                        if( obj[i]==obj[j] ){
                                obj.splice( j, 1 );
                                j--;
                        }
                }
        }
}
function gm_compare(a,b){
        return parseInt(a)-parseInt(b);
}

'1 2 3'.replace(/\d+/g,parseInt)  ？  
结果  "1 NaN 3"   求解？  为什么








